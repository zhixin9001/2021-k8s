Kubernetes笔记(6) - Service和Ingress

### Service资源概述
Service是Kubernetes的核心资源类型之一，它通过规则定义出由多个Pod对象组合而成的逻辑集合，以及访问这组Pod的策略。
由Deployment等控制器管理的Pod对象在中断或扩缩容后，Pod组合的IP地址都会发生变化，而引入Service资源后，就可以基于标签选择器将一组Pod定义成一个逻辑组合，并通过自己的IP地址和端口调度代理请求至组内的Pod对象之上，它向客户端隐藏了真实的、处理用户请求的Pod资源，使得客户端的请求看上去就像是由Service直接处理并进行响应的一样。而且Service与Pod对象之间通过标签选择器以松耦合的方式关联，它可以先于Pod对象创建而不会发生错误。

#### 创建Service资源
Service资源基本的配置清单：
```
apiVersion: v1
kind: Service
metadata:
  name: myapp-svc
spec:
  selector:
    app: myapp  
  ports:
  - name: http
    port: 80
    targetPort: 80
    protocol: TCP
```
Service资源myapp-svc通过标签选择器关联至标签为“app=myapp”的各Pod对象，它会自动创建名为myapp-svc的Endpoints资源对象，并自动配置一个ClusterIP，暴露的端口由port字段进行指定，后端各Pod对象的端口则由targetPort给出。
分别查看service和endpoint的状态：
```
kubectl get svc myapp-svc
kubectl get endpoints myapp-svc
```

#### 向Service对象请求服务
Service资源的默认类型为ClusterIP，它仅能接收来自于集群中的Pod对象中的客户端程序的访问请求。所以为了测试，会创建一个专用的Pod对象，利用其交互式接口来访问service资源。
```
kubectl run cirros-$RANDOM --rm -it --image=cirros -- sh
```
启动了一个运行CirrOS容器的Pod，CirrOS是设计用来进行云计算环境测试的Linux微型发行版，它自带HTTP客户端工具curl等。
在容器的交互式接口访问ClusterIP:Port
```
/ # curl http://10.105.246.145:80
Hello MyApp | Version: v1 | <a href="hostname.html">Pod Name</a>
```
Kubernetes集群默认的Service代理模式为iptables，而且使用随机调度算法，因此Service会将客户端请求随机调度至与其关联的某个后端Pod资源上。

#### Service会话粘性
Service资源还支持Session affinity（会话粘性）机制，它能够将来自同一个客户端的请求始终转发至同一个后端的Pod对象，适用于需要基于客户端身份保存某些私有信息，并根据这些私有信息追踪用户的活动等一类的需求。
Service资源通过spec.sessionAffinity和spec.sessionAffinityConfig两个字段配置粘性会话：
- sessionAffinity字段用于定义要使用的粘性会话的类型，它仅支持使用“None”和“ClientIP”两种属性值。
  - None：不使用sessionAffinity，默认值。
  - ClientIP：基于客户端IP地址识别客户端身份，把来自同一个源IP地址的请求始终调度至同一个Pod对象。
- sessionAffinityConfig用于配置其会话保持的时长，其可用的时长范围为“1～86400”，默认为10800秒

但是Service资源的Session affinity机制仅能基于客户端IP地址识别客户端身份，它会把经由同一个NAT服务器进行源地址转换的所有客户端识别为同一个客户端，调度粒度粗糙且效果不佳，因此实践中并不推荐使用此种方法实现粘性会话。

#### 服务发现
Service为Pod中的服务类应用提供了一个稳定的访问入口，但Pod客户端中的应用如何得知某个特定Service资源的IP和端口呢，这就需要借助服务发现机制来进行。
服务发现机制的基本实现，一般是事先部署好一个网络位置较为稳定的服务注册中心（也称为服务总线），服务提供者（服务端）向注册中心注册自己的位置信息，并在变动后及时予以更新，服务消费者则周期性地从注册中心获取服务提供者的最新位置信息从而“发现”要访问的目标服务资源。
在K8S中可以基于CoreDNS进行服务发现，甚至也可以使用简单的环境变量方式。

#### 服务暴露
Service的IP地址默认仅在集群内可达，集群外部想访问服务，需要首先进行服务的暴露。

##### Service的类型
Service有四种类似ClusterIP、NodePort、LoadBalancer和ExternalName
1. ClusterIP：通过集群内部IP地址暴露服务，此地址仅在集群内部可达，而无法被集群外部的客户端访问；
2. NodePort：建立在ClusterIP类型之上，其在每个Node的IP地址的某静态端口（NodePort）暴露服务，NodePort的路由目标为ClusterIP，简单来说，NodePort类型就是在工作节点的IP地址上选择一个端口用于将集群外部的用户请求转发至目标Service的ClusterIP和Port，这种类型的Service既可如ClusterIP一样受到集群内部客户端Pod的访问，也会受到集群外部客户端通过套接字NodeIP:NodePort进行的请求；
3. LoadBalancer：建构在NodePort类型之上，其通过cloud provider提供的负载均衡器将服务暴露到集群外部，LoadBalancer类型的Service会指向关联至Kubernetes集群外部的某个负载均衡设备，该设备通过工作节点之上的NodePort向集群内部发送请求流量，这种Service的优势在于，能够把来自于集群外部客户端的请求调度至所有节点（或部分节点）的NodePort之上，而不是依赖于客户端自行决定连接至哪个节点，从而避免了因客户端指定的节点故障而导致的服务不可用；
4. ExternalName：通过将Service映射至由externalName字段的内容指定的主机名来暴露服务，此主机名需要被DNS服务解析至CNAME类型的记录。这种类型并非定义由Kubernetes集群提供的服务，而是把集群外部的某服务以DNS CNAME记录的方式映射到集群内，从而让集群内的Pod资源能够访问外部的Service的一种实现方式，这种类型的Service没有ClusterIP和NodePort，也没有标签选择器用于选择Pod资源。

##### NodePort
NodePort型的Service资源，其配置清单与前面默认的ClusterIP类型类似，只是要显式地在spec下指定`type: NodePort`
此外还可以指定Node端口，但必须在30000-32767之间，而且推荐使用集群自动分配的端口以避免端口的冲突。

##### LoadBalancer
NodePort类型的Service资源虽然能够于集群外部访问得到，但外部客户端必须得事先得知NodePort和集群中至少一个节点的IP地址，且选定的节点发生故障时，客户端还得自行选择请求访问其他的节点，此外有时节点并不允许外界访问，LoadBalancer类型可将请求流量调度至各节点的NodePort之上。
创建LoadBalancer类型需要指定`type: LoadBalancer`，







